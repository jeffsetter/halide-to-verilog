HALIDE_PATH = Halide_CoreIR
COREIR_PATH = coreir

all:
	mkdir -p build
#	make build/conv_1_2_compare SIZE="10,10" CULL="0,10,1,10"
	make build/conv_3_1_compare SIZE="10,10" CULL="2,10,0,10"
	make build/conv_bw_compare SIZE="64,64" CULL="2,64,2,64" 

${HALIDE_PATH}:
	git clone ${HALIDE_REPO} ${HALIDE_PATH}

${COREIR_PATH}:
	git clone ${COREIR_REPO} -b dev ${COREIR_PATH}
	${MAKE} -C ${COREIR_PATH}
crop: ${COREIR_PATH}
	${MAKE} -C ${COREIR_PATH}/tools/crop

#REMEMBER TO SET LD_LIBRARY_PATH
# setenv LD_LIBRARY_PATH $PWD/coreir/lib:$LD_LIBRARY_PATH
install:
	${MAKE} ${HALIDE_PATH}
	${MAKE} ${COREIR_PATH}
	${MAKE} crop
	source setenv.sh

# Run halide to produce coreir json and halide cpu output image
.PRECIOUS: build/%_design_prepass.json build/%_input.png build/%_halide_output.png
build/%_design_prepass.json build/%_input.png build/%_halide_output.png: ${HALIDE_PATH}/apps/coreir_examples/% 
        # remake the json and cpu output image for our test app
	@echo; echo Making $@ because of $?
        # E.g. '$*' = "pointwise" when building "build/pointwise/correct.txt"
	make -C ${HALIDE_PATH}/apps/coreir_examples/$*/ clean design_top.json out.png $(SILENT_FILTER_HF)

        # copy over all pertinent files
	mkdir -p build
	cp ${HALIDE_PATH}/apps/coreir_examples/$*/design_prepass.json build/$*_design_prepass.json
	cp ${HALIDE_PATH}/apps/coreir_examples/$*/input.png           build/$*_input.png
	cp ${HALIDE_PATH}/apps/coreir_examples/$*/out.png             build/$*_halide_output.png

# convert input and halide output images from png to raw format
.PRECIOUS: build/%_input.raw build/%_halide_output.raw
build/%_input.raw build/%_halide_output.raw: build/%_input.png build/%_halide_output.png
	./${HALIDE_PATH}/apps/coreir_examples/tools/steveconvert.csh build/$*_input.png build/$*_input.raw
	./${HALIDE_PATH}/apps/coreir_examples/tools/steveconvert.csh build/$*_halide_output.png build/$*_halide_output.raw

# use coreir to convert coreir json to verilog
.PRECIOUS: build/%_top.v
build/%_top.v: build/%_design_prepass.json
	./${COREIR_PATH}/bin/coreir -i build/$*_design_prepass.json -o build/$*_top.v --load_libs ${COREIR_PATH}/lib/libcoreir-commonlib.so
	@echo -e "\033[0;32m coreir verilog generated \033[0m"

# use verilator and input image to execute verilog design and generate output image
.PRECIOUS: build/%_verilog_output_uncropped.raw
build/%_verilog_output_uncropped.raw: build/%_input.raw build/%_top.v
	cp build/$*_top.v ${COREIR_PATH}/tools/verilator/top.v
	cp build/$*_input.raw ${COREIR_PATH}/tools/verilator/input.raw

	cd ${COREIR_PATH}/tools/verilator && \
	verilator --cc top.v --exe tb.cpp && \
	cd obj_dir && \
	make -f Vtop.mk CXXFLAGS="-std=c++11 -Wall -fPIC" CXX=g++-4.9 LINK=g++-4.9 && \
	./Vtop -i ../input.raw -o output.raw

	cp ${COREIR_PATH}/tools/verilator/obj_dir/output.raw build/$*_verilog_output_uncropped.raw

	rm ${COREIR_PATH}/tools/verilator/top.v
	rm ${COREIR_PATH}/tools/verilator/input.raw
	rm -rf {COREIR_PATH}/tools/verilator/obj_dir
	@echo -e "\033[0;32m verilog output image generated using verilator \033[0m"

# crop output image generated by verilog design
#   crop use defined by CULL="y_start,y_end,x_start,x_end"
#   example use: make build/conv_bw_verilog_output.raw SIZE="64,64" CULL="2,64,2,64"
.PRECIOUS: build/%_verilog_output.raw
build/%_verilog_output.raw: build/%_verilog_output_uncropped.raw crop
	./${COREIR_PATH}/bin/crop -i build/$*_verilog_output_uncropped.raw -o build/$*_verilog_output.raw -s ${SIZE} -c ${CULL}

# compare the halide and verilog generated outputs
.PHONY: build/%_compare
build/%_compare: build/%_verilog_output.raw build/%_halide_output.raw
	diff build/$*_verilog_output.raw build/$*_halide_output.raw
	@echo -e "\033[0;32mPASSED: $*; verilog and halide generate matching images! \033[0m"

clean:
	rm -rf build
	rm -rf {COREIR_PATH}/tools/verilator/obj_dir
